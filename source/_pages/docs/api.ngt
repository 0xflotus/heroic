<h1>API</h1>

<h2>Endpoints</h2>

<api-endpoint path="/status" method="GET">
  <p>
    Query for the status of an instance.
  </p>

  <p>
    The status code <span class="status">503</span> is used to indicate to load balancers that a service is
    not available for requests right now.
  </p>

  <api-accept empty="true"></api-accept>

  <api-response status="200">
    <h4>Example <span class="status">200</span> Response</h4>

    <codeblock language="json">
    {
      "ok": true,
      "consumers": {
        "ok": true,
        "available": 0,
        "ready": 0,
        "errors": 0,
        "consumingThreads": 1,
        "totalThreads": 1
      },
      "backends": {
        "ok": true,
        "available": 0,
        "ready": 0
      },
      "metadataBackends": {
        "ok": true,
        "available": 0,
        "ready": 0
      },
      "cluster": {
        "ok": true,
        "onlineNodes": 1,
        "offlineNodes": 0
      }
    }
    </codeblock>
  </api-response>

  <api-response status="503">
    <h4>Example <span class="status">503</span> Response</h4>

    <p>
      A <span class="status">503</span> will still return a response body, however the root key <code>.ok</code> will have the value <code>false</code>.
    </p>

    <p>
      The below document shows that there is something wrong with the configured consumers, in this case it is because the number of <code>consumingThreads</code> is not the same as the <code>totalThreads</code>
    </p>

    <codeblock language="json">
    {
      "ok": false,
      "consumers": {
        "ok": false,
        "available": 0,
        "ready": 0,
        "errors": 0,
        "consumingThreads": 0,
        "totalThreads": 1
      },
      ...
    }
    </codeblock>
  </api-response>
</api-endpoint>

<api-endpoint path="/query" method="POST">
  <p>
    Query and aggregate metrics.
  </p>

  <api-accept curl-data='{"range": {"type": "relative"}, "filter": ["and", ["key", "foo"], ["=", "foo", "bar"], ["+", "role"]], "groupBy": ["site"], "aggregators": []}'>
    <api-type>
      <api-field required="true" name="range" type-href="QueryDateRange">
        The range in time for which to query
      </api-field>

      <api-field name="filter" type-href="Filter">
        <p>
          A statement used to filter down the selected time series.
          Each individual filtering field (<code>filter</code>, <code>key</code>, <code>tags</code>, and <code>hasTags</code>) may be empty.
          At least one must be specified to make up a valid filter.
        </p>

        <p>
          See <a ui-sref="docs.filter_dsl">Filter DSL</a> for details on how to build a filter.
        </p>
      </api-field>

      <api-field name="aggregators" type-href="Aggregation">
        Aggregators used to downsample the response.
      </api-field>

      <api-field name="groupBy">
        <p>
          Will create several result groups from the given keys.
          Series will be aggregated on a per-group basis.
        </p>

        <h5>Example 1.</h5>

        Given time series <code language="json">{"a": 1, "b": 2}</code> and <code language="json">{"b": 3, "c": 4}</code>, and a <code>groupBy</code> of <code language="json">["a", "b"]</code>
        the returned result groups would be <code language="json">[{"a": 1, "b": 2}, {"a": null, "b": 3}]</code>.
      </api-field>
    </api-type>

    <h4>Example Request</h4>

    <codeblock language="json">
    {
      "range": {"type": "relative"},
      "filter": ["and", ["key", "foo"], ["=", "foo", "bar"], ["+", "role"]],
      "groupBy": ["site"],
      "aggregators": []
    }
    </codeblock>
  </api-accept>

  <api-response>
    <api-type>
      <api-field name="range" type-json="{start: <number>, end: <number>}">
        The range in time for which to query
      </api-field>

      <api-field name="errors" type-array-href="RequestError">
        Potential errors returned either from different shards or for specific
        time series. The presence of an error does not cause the entire query
        to fail, instead it is up to the client to use this information to
        decide if the response is reliable enough.
      </api-field>

      <api-field name="result" type-array-href="ShardedResultGroup">
        An array of result groups.
      </api-field>

      <api-field name="statistics" type-href="Statistics">
        Statistics about the current query.
        This field should be inspected for errors which will have caused the result
        to be inconsistent.
      </api-field>
    </api-type>

    <h4>Example Response</h4>

    <codeblock language="json">
    {
      "errors": [
        {
          "type": "node",
          "nodeId": "abcd-efgh",
          "nodeUri": "http://example.com",
          "tags": {"site": "lon"},
          "error": "Connection refused",
          "internal": true
        },
        {
          "type": "series",
          "tags": {"site": "lon"},
          "error": "Aggregation too heavy, too many rows from the database would have to be fetched to satisfy the request!",
          "internal": true
        }
      ],
      "result": [
        {
          "hash": "deadbeef",
          "tags": {"foo": "bar"},
          "values": [[1300000000000, 42.0]]
        },
        {
          "hash": "beefdead",
          "tags": {"foo": "baz"},
          "values": [[1300000000000, 42.0]]
        }
      ],
      "range": {},
      "statistics": {}
    }
    </codeblock>
  </api-response>
</api-endpoint>


<api-endpoint path="/write" method="POST">
  <p>
    Used for writing data into heroic directly.
  </p>

  <api-accept curl-data='{"series": {"key": "foo", "tags": {"site": "lon", "host": "www.example.com"}}, "data":[[1300000000000, 42.0], [1300001000000, 84.0]]}'>
    <api-type>
      <api-field name="series" required="true" type-href="Series">
        <p>Time series to write data to.</p>
      </api-field>

      <api-field name="data" required="true" type-array-href="Point">
        <p>Data to write.</p>
      </api-field>
    </api-type>

    <h4>Example Request</h4>

    <codeblock language="json">
    {
      "series": {"key": "foo", "tags": {"site": "lon", "host": "www.example.com"}},
      "data": [[1300000000000, 42.0], [1300001000000, 84.0]]
    }
    </codeblock>
  </api-accept>

  <api-response status="200">
    <h4>Example <span class="status">200</span> Response</h4>
    <codeblock language="json">
    {
      "ok": true
    }
    </codeblock>
  </api-response>
</api-endpoint>

<api-endpoint path="/metadata/tags" method="POST">
  <p>
    Query for available tag combinations.
  </p>

  <div ng-include="'_pages/docs/api/accept-metadata-query-body.ngt'"></div>

  <api-response status="200">
    <h4>Example <span class="status">200</span> Response</h4>
    <codeblock language="json">
    {
      "result": {
        "role": ["database", "webfrontend"],
        "host": ["database.example.com", "webfrontend.example.com"]
      },
      "sampleSize": 2
    }
    </codeblock>
  </api-response>
</api-endpoint>

<api-endpoint path="/metadata/keys" method="POST">
  <p>
    Use to query for keys.
  </p>

  <div ng-include="'_pages/docs/api/accept-metadata-query-body.ngt'"></div>

  <api-response status="200">
    <h4>Example <span class="status">200</span> Response</h4>

    <codeblock language="json">
    {
      "result": ["foo", "bar"],
      "sampleSize": 5
    }
    </codeblock>
  </api-response>
</api-endpoint>

<api-endpoint path="/metadata/series" method="POST">
  <p>
    Get all series metadata matching the given filter.
  </p>

  <div ng-include="'_pages/docs/api/accept-metadata-query-body.ngt'"></div>

  <api-response status="200">
    <h4>Example <span class="status">200</span> Response</h4>

    <codeblock language="json">
    [
      {"key": "foo", "tags": {"site": "lon"}},
      {"key": "foo", "tags": {"site": "sto"}}
    ]
    </codeblock>
  </api-response>
</api-endpoint>

<api-endpoint path="/metadata/series" method="PUT">
  <p>
    Write the given series metadata.
  </p>

  <div ng-include="'_pages/docs/api/accept-series.ngt'"></div>

  <api-response status="200">
    <h4>Example <span class="status">200</span> Response</h4>

    <codeblock language="json">
    [
      {"key": "foo", "tags": {"site": "lon"}},
      {"key": "foo", "tags": {"site": "sto"}}
    ]
    </codeblock>
  </api-response>
</api-endpoint>

<api-endpoint path="/metadata/series" method="DELETE">
  <p>
    Delete all series metadata matching the given filter.
  </p>

  <div ng-include="'_pages/docs/api/accept-metadata-query-body.ngt'"></div>

  <api-response status="200">
    <h4>Example <span class="status">200</span> Response</h4>

    <codeblock language="json">
    [
      {"key": "foo", "tags": {"site": "lon"}},
      {"key": "foo", "tags": {"site": "sto"}}
    ]
    </codeblock>
  </api-response>
</api-endpoint>

<api-endpoint path="/metadata/series-count" method="POST">
  <p>
    Count the number of time series matching a given filter.
  </p>

  <api-accept curl-data='{"filter": ["and", ["key", "system"], ["=", "role", "database"]]}'>
    <api-type>
      <api-field required="false" name="filter" type-href="Filter">
        A filter to use when counting series.
      </api-field>

      <api-field required="false" name="range" type-href="QueryDateRange">
        Range for which to count series.
      </api-field>
    </api-type>

    <h4>Example Request</h4>

    <codeblock language="json">
    {"filter": ["and", ["key", "system"], ["=", "role", "database"]]}
    </codeblock>
  </api-accept>
  <api-response status="200">
    <h4>Example <span class="status">200</span> Response</h4>
    <codeblock language="json">
    {
      "errors": [],
      "limited": false,
      "count": 10001
    }
    </codeblock>
  </api-response>
</api-endpoint>

<h2>Types</h2>

<api-type name="Series">
  <p>
    Java Class: <a git-href-java="heroic-component">com.spotify.heroic.common.Series</a>
  </p>

  <p>
    See the <a ui-sref="^.data_model({'#': 'series'})">Series section in Data Model</a>
    for details about <em>what</em> a series is.
  </p>

  <api-field required="true" name="key" type-json='<string>'>
    Key of the series.
  </api-field>

  <api-field required="true" name="tags" type-json='{<string>: <string>, ...}'>
    Tags of the series.
  </api-field>
</api-type>

<api-type name="Point" kind="structural">
  <p>
    Java Class: <a git-href-java="heroic-component">com.spotify.heroic.metric.Point</a>
  </p>

  <p>
    See the <a ui-sref="^.data_model({'#': 'data-points'})">Points section in Data Model</a>
    for more details about <em>what</em> a point is.
  </p>

  <api-field required="true" name="datapoint" type-json='[<timestamp>, <value>]'>
    <p>
      A single datapoint.
    </p>

    <p>
      The <code language="json">&lt;timestamp&gt;</code> is the number of milliseconds since unix epoch.
    </p>

    <p>
      The <code language="json">&lt;value&gt;</code> is the sample value.
    </p>
  </api-field>
</api-type>

<api-type name="Event" kind="structural">
  <p>
    Java Class: <a git-href-java="heroic-component">com.spotify.heroic.metric.Event</a>
  </p>

  <p>
    See the <a ui-sref="^.data_model({'#': 'events'})">Events section in Data Model</a>
    for more details about <em>what</em> an event is.
  </p>

  <api-field required="true" name="datapoint" type-json='[<timestamp>, {<payload>}]'>
    <p>
      A single event.
    </p>

    <p>
      The <code language="json">&lt;timestamp&gt;</code> is the number of milliseconds since unix epoch.
    </p>

    <p>
      The <code language="json">&lt;payload&gt;</code> is the sample payload.
    </p>
  </api-field>
</api-type>

<api-type kind="structural" name="Filter">
  <p>
    Java Class: <a git-href-java="heroic-component">com.spotify.heroic.filter.Filter</a>
  </p>

  <p>
    The structure of a filter is explained in detail in
    the <a ui-sref="docs.filter_dsl">Filter DSL</a> documentation.
    This will only be a brief, syntactical overview.
  </p>

  <api-field name="and" type-json='["and", <filter>, ...]'>
    A boolean 'and' operation, evaluates to <code language="json">true</code> if <em>all</em> of the nested <code language="json">&lt;filter&gt;</code>'s are <code language="json">true</code>, otherwise <code language="json">true</code>.
  </api-field>

  <api-field name="or" type-json='["or", <filter>, ...]'>
    A boolean 'or' operation, evaluates to <code language="json">true</code> if <em>any</em> of the nested <code language="json">&lt;filter&gt;</code>'s are <code language="json">true</code>, otherwise <code language="json">false</code>.
  </api-field>

  <api-field name="not" type-json='["not", <filter>]'>
    A boolean 'not' operation, evaluates to <code language="json">true</code> if the nested <code language="json">&lt;filter&gt;</code> is <code language="json">false</code>.
  </api-field>
</api-type>

<!-- anchor to use when linking to QueryDateRange -->
<span api-type-id="QueryDateRange"></span>

<api-type name="QueryDateRange.Absolute">
  <p>
    Java Class: <a git-href-java="heroic-core">com.spotify.heroic.http.query.QueryDateRange</a>
  </p>

  <p>
    An absolute time span.
  </p>

  <api-field required="true" name="type" type-json='"absolute"'>
    Type of the absolute date range.
  </api-field>

  <api-field required="true" name="start" type-json='<number>'>
    Starting timestamp in milliseconds from the unix epoch.
  </api-field>

  <api-field required="true" name="end" type-json='<number>'>
    Ending timestamp in milliseconds from the unix epoch.
  </api-field>
</api-type>

<api-type name="QueryDateRange.Relative">
  <p>
    Java Class: <a git-href-java="heroic-core">com.spotify.heroic.http.query.QueryDateRange</a>
  </p>

  <p>
    Relative date ranges range from <em>the current</em> time, to a specific
    point in the past.
  </p>

  <p>
    This object tells the distance to the point in the past.
  </p>

  <api-field required="true" name="type" type-json='"relative"'>
    Type of the relative date range.
  </api-field>

  <api-field name="unit" type-json='<string>'>
    <p>
      Unit to use for <code>value</code>
    </p>

    <p>
      <code>unit</code> must be one of.
    </p>

    <ul class="list-inline">
      <li><code language="json">"MILLISECONDS"</code></li>
      <li><code language="json">"SECONDS"</code></li>
      <li><code language="json">"MINUTES"</code></li>
      <li><code language="json">"HOURS"</code></li>
      <li><code language="json">"DAYS"</code></li>
      <li><code language="json">"WEEKS"</code></li>
      <li><code language="json">"MONTHS"</code></li>
    </ul>
  </api-field>

  <api-field name="value" type-json='<number>'>
    How many <code>unit</code> timespans back in time this date starts.
  </api-field>
</api-type>

<api-type name="Aggregation">
  <p>
    Java Class: <a git-href-java="heroic-core">com.spotify.heroic.metric.Aggregation</a>
  </p>

  <p>
    An aggregation is responsible for analysing and sampling a larger dataset into a smaller, more manageable one.
    For details on all available aggregations, see the <a ui-sref="^.aggregations">Aggregations Section</a>.
  </p>

  <p>
    This object tells the distance to the point in the past.
  </p>

  <api-field required="true" name="type" type-json='"relative"'>
    Type of the aggregation.
  </api-field>

  <api-field name="sampling" type-href='Sampling'>
    Sampling to use with aggregation.
  </api-field>
</api-type>

<api-type name="ShardedResultGroup">
  <p>
    Java Class: <a git-href-java="heroic-component">com.spotify.heroic.metric.ShardedResultGroup</a>
  </p>

  <api-field required="true" name="type" type-json='"series"|"events"|"spreads"|"groups"'>
    Type of the result group.
  </api-field>

  <api-field required="true" name="hash" type-json='<string>'>
    A string uniquely identifying this result group.
  </api-field>

  <api-field required="true" name="shard" type-json='{<string>: <string>}'>
    The shard that the result group came from.
  </api-field>

  <api-field required="true" name="cadence" type-json='<number>'>
    The cadence at which a client can expect samples in this group to adhere to.
  </api-field>

  <api-field required="true" name="values" type-json='[[<timestamp>, <sample>], ..]'>
    A list of values of the given <code>type</code>.

    <ul>
      <li>
        <code language="json">"series"</code> indicates that the
        <code language="json">&lt;sample&gt;</code> is a <code language="json">&lt;number&gt;</code>.
      </li>
      <li>
        <code language="json">"events"</code> indicates that the
        <code language="json">&lt;sample&gt;</code> is an <code language="json">{&lt;string&gt;: &lt;any&gt;}</code> object.
      </li>
    </ul>
  </api-field>

  <api-field required="true" name="tags" type-json='{<string>: <string>}'>
    The set of tags that have a single value.
  </api-field>

  <api-field required="true" name="tagCounts" type-json='{<string>: <number>}'>
    The set of tags that have more than a single value, the number is the number of distinct tags.
  </api-field>
</api-type>

<api-type name="Statistics">
  <p>
    Java Class: <a git-href-java="heroic-component">com.spotify.heroic.common.Statistics</a>
  </p>

  <api-field name="counters" type-json='{<string>: <number>}'>
    Counters containing statistics.
  </api-field>
</api-type>
