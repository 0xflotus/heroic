<h2>Filter DSL</h2>

<p>
  Heroic uses a JSON-based DSL to define filters.
  A filter reduces the number of selected time series, if no filter (or the <a ui-sref="{'#':'filter-true'}">true filter</a>) is used, then it is implied that <em>all</em> time series in the database is selected.
</p>

<img style="width: 100%;" src="images/filter-dsl.svg"></img>

<p>
  This filter can either be expressed using <a ui-sref="{'#': 'json-dsl'}">JSON</a>, or as
  <a ui-sref="{'#': 'parsable-dsl'}">a parsable DSL</a>.

  Because the parsable syntax is more human friendly, examples will be written
  using it, like the following.
</p>

<pre><code language="hql">
$key = "hello kitty" and host = foo.example.com
</code></pre>

<h3 id="json-dsl">JSON</h3>

<p>
  A filter expressed as JSON a syntax tree which follows polish notation.
</p>

<p>
  JSON is typically used when a filter is built programatically, because the
  syntax is unambigious in terms of precedence and escaping.
  There is also a ton of language support for it, and it meshes well with
  restful APIs.
</p>

<p>
  The following is an example filter expressed both in a parsable form, and
  in JSON.
</p>

<pre><code language="hql">
$key = "hello kitty" and host = foo.example.com
</code><code language="json">
["and", ["$key", "hello kitty"], ["=", "host", "foo.example.com"]]
</code></pre>

<h3 id="parsable-dsl">Parsable DSL</h3>

<p>
  The parsable form was developed to make it easier for humans to express
  filters in a manner which is most convenient.
  The language is infix, and simple strings do not have to be escaped (e.g. <code language="hql">host</code> vs. <code language="hql">&quot;host&quot;</code>)
</p>

<div class="callout callout-danger">
  <h4>Experimental</h4>
  <p>
    The parsable DSL should currently be considered experimental and might be
    subject to future changes.
  </p>
</div>

<h3>Filters</h3>

<h4>Boolean Operators</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <th></th>
    <th>Description</th>
    <th>Parsed</th>
    <th>JSON</th>
  </tr>

  <tr>
    <th scope="row">And</th>
    <td>Matches if all child statements match. <code language="hql">true</code> if empty.</td>
    <td><pre><code language="hql">&lt;a&gt; and &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["and", &lt;a&gt;, &lt;b&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Or</th>
    <td>Matches if any child statements match. <code language="hql">false</code> if empty.</td>
    <td><pre><code language="hql">&lt;a&gt; or &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["or", &lt;a&gt;, &lt;b&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Not</th>
    <td>Matches if child statement does not match.</td>
    <td><pre><code language="hql">!&lt;a&gt;</code></pre></td>
    <td><pre><code language="json">["not", &lt;a&gt;]</code></pre></td>
  </tr>
</table>
</div>

<h4>Operators</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <th></th>
    <th>Parsed</th>
    <th>JSON</th>
  </tr>

  <tr>
    <th scope="row">Tag Matches</th>
    <td><pre><code language="hql">&lt;a&gt; = &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["=", &lt;a&gt;, &lt;b&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Does Not Match</th>
    <td><pre><code language="hql">&lt;a&gt; != &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["not", ["=", &lt;a&gt;, &lt;b&gt;]]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Starts With</th>
    <td><pre><code language="hql">&lt;a&gt; ^ &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["^", &lt;a&gt;, &lt;b&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Does Not Start With</th>
    <td><pre><code language="hql">&lt;a&gt; !^ &lt;b&gt;</code></pre></td>
    <td><pre><code language="json">["not", ["^", &lt;a&gt;, &lt;b&gt;]]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Key Matches</th>
    <td><pre><code language="hql">$key = &lt;a&gt;</code></pre></td>
    <td><pre><code language="json">["key", &lt;a&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Key Does Not Match</th>
    <td><pre><code language="hql">$key != &lt;a&gt;</code></pre></td>
    <td><pre><code language="json">["not", ["key", &lt;a&gt;]]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Exists</th>
    <td><pre><code language="hql">+&lt;a&gt;</code></pre></td>
    <td><pre><code language="json">["+", &lt;a&gt;]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag In</th>
    <td><pre><code language="hql">&lt;a&gt; in [&lt;b&gt;, ..]</code></pre></td>
    <td><pre><code language="json">["or", ["=", &lt;a&gt;, &lt;b&gt;], ..]</code></pre></td>
  </tr>

  <tr>
    <th scope="row">Tag Not In</th>
    <td><pre><code language="hql">&lt;a&gt; not in [&lt;b&gt;, ..]</code></pre></td>
    <td><pre><code language="json">["not", ["or", ["=", &lt;a&gt;, &lt;b&gt;], ..]]</code></pre></td>
  </tr>
</table>
</div>

<h4>Parsed Primitives</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <th scope="row">Simple String</th>
    <td>
      String made up of a limited set of characters for convenience.
      It must not match a <a href="#parsed-keyword">parsed keyword</a>.
    </td>
    <td>
      <pre><code language="hql">hello.world</code></pre>
    </td>
  </tr>

  <tr>
    <th scope="row">Quoted String</th>
    <td>String which is quoted to support <em>any</em> set of characters. Supports the same <a href="https://docs.oracle.com/javase/tutorial/java/data/characters.html">escape sequences as Java</a>.</td>
    <td>
      <pre><code language="hql">"hello world"</code></pre>
    </td>
  </tr>
</table>
</div>

<h4>Parsed Arithmetic Expressions</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <th scope="row">Addition</th>
    <td><pre><code language="hql">&lt;a&gt; + &lt;b&gt;</code></pre></td>
    <td>
      Valid operands are:
      <code language="hql">&lt;string&gt; + &lt;string&gt;</code>,
      and <code language="hql">&lt;number&gt; + &lt;number&gt;</code>.
    </td>
  </tr>

  <tr>
    <th scope="row">Subtraction</th>
    <td><pre><code language="hql">&lt;a&gt; - &lt;b&gt;</code></pre></td>
    <td>
      Valid operands are:
      <code language="hql">&lt;number&gt; - &lt;number&gt;</code>.
    </td>
  </tr>
</table>
</div>

<h4>Parsed Durations</h4>

<p>
  Durations are represented as a numeric component with a suffix, like <code language="hql">3H</code>
</p>

<p>
  Valid suffixes are:
</p>

<ul>
  <li><b>ms</b> - for milliseconds</li>
  <li><b>s</b> - for seconds</li>
  <li><b>m</b> - for minutes</li>
  <li><b>H</b> - for hours</li>
  <li><b>d</b> - for days</li>
  <li><b>w</b> - for weeks</li>
</ul>

<p>
  Durations support arithmetic expressions with each other and numbers.
</p>

<p>
  The following is a valid expression:
</p>

<codeblock language="hql">
$now - (1d + 1H)
</codeblock>

<h4 id="parsed-keyword">Parsed Keywords</h4>

<div class="table-responsive">
<table class="table table-bordered">
  <tr>
    <td><code language="hql">$key</code></td>
    <td>Can be used in most places a tag is expected. It indicates that the given expression should match the special field <em>key</em> instead of a tag.</td>
  </tr>

  <tr>
    <td><code language="hql">$now</code></td>
    <td>Expands to the current (server-side) timestamp in milliseconds.</td>
  </tr>
</table>
</div>
